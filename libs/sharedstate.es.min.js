function t(){let t;return[new Promise(((e,s)=>{t=e})),t]}const e=4;class s{constructor(t,e={}){this._url=t,this._ws,this._connecting=!1,this._connected=!1,this._options=e,this._retries=0,this._connect_promise_resolvers=[]}get connecting(){return this._connecting}get connected(){return this._connected}get url(){return this._url}get options(){return this._options}connect(){this.connecting||this.connected?console.log("Connect while connecting or connected"):this._is_terminated()?console.log("Terminated"):(this._ws=new WebSocket(this._url),this._connecting=!0,this._ws.onopen=t=>this._on_open(t),this._ws.onmessage=t=>this.on_message(t.data),this._ws.onclose=t=>this._on_close(t),this._ws.onerror=t=>this.on_error(t),this.on_connecting())}_on_open(t){this._connecting=!1,this._connected=!0;for(const t of this._connect_promise_resolvers)t();this._connect_promise_resolvers=[],this._retries=0,this.on_connect()}_on_close(t){this._connecting=!1,this._connected=!1,this.on_disconnect(t),this._retries+=1,this._is_terminated()||setTimeout((()=>{this.connect()}),1e3*this._retries)}_is_terminated(){const{retries:t=e}=this._options;return this._retries>=t&&(console.log(`Terminated: Max retries reached (${t})`),this._connecting=!1,this._connected=!0,this._ws.onopen=void 0,this._ws.onmessage=void 0,this._ws.onclose=void 0,this._ws.onerror=void 0,this._ws=void 0,!0)}on_connecting(){const{debug:t=!1}=this._options;t&&console.log(`Connecting ${this.url}`)}on_connect(){console.log(`Connect  ${this.url}`)}on_error(t){const{debug:e=!1}=this._options;e&&console.log(`Error: ${t}`)}on_disconnect(t){console.error(`Disconnect ${this.url}`)}on_message(t){const{debug:e=!1}=this._options;e&&console.log(`Receive: ${t}`)}send(t){if(this._connected)try{this._ws.send(t)}catch(t){console.error(`Send fail: ${t}`)}else console.log("Send drop : not connected")}connectedPromise(){const[e,s]=t();return this.connected?s():this._connect_promise_resolvers.push(s),e}}class n{constructor(t,e,s={}){this._options=s,this._terminated=!1,this._ssclient=t,this._path=e,this._handlers=[],this._map=new Map}_ssclient_terminate(){this._terminated=!0,this._handlers=[]}_ssclient_update(t={}){if(this._terminated)throw new Error("collection already terminated");const{remove:e,insert:s,reset:n=!1}=t,i=new Map;if(n){for(const t of this._map.values())i.set(t.id,{id:t.id,new:void 0,old:t});this._map=new Map}else for(const t of e){const e=this._map.get(t);null!=e&&(this._map.delete(t),i.set(t,{id:t,new:void 0,old:e}))}for(const t of s){const e=t.id,s=i.get(e),n=null!=s?s.old:this._map.get(e);this._map.set(e,t),i.set(e,{id:e,new:t,old:n})}this._notify_callbacks([...i.values()])}_notify_callbacks(t){this._handlers.forEach((function(e){e.handler(t)}))}get size(){return this._map.size}has(t){return this._map.has(t)}get(t){return null==t?[...this._map.values()]:this._map.get(t)}update(t={}){if(this._terminated)throw new Error("collection already terminated");const{insert:e=[]}=t;return t.insert=e.map((t=>(t.id=t.id||function(t){for(var e="",s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",n=0;n<t;n++)e+=s.charAt(Math.floor(52*Math.random()));return e}(10),t))),this._ssclient.update(this._path,t)}add_callback(t){const e={handler:t};return this._handlers.push(e),e}remove_callback(t){const e=this._handlers.indexOf(t);e>-1&&this._handlers.splice(e,1)}}class i{constructor(t,e,s={}){this._terminiated=!1,this._coll=t,this._id=e,this._options=s,this._handlers=[],this._handle=this._coll.add_callback(this._onchange.bind(this))}_onchange(t){if(this._terminated)throw new Error("variable terminated");for(const e of t)e.id==this._id&&(this._item=e.new,this.notify_callbacks(e))}add_callback(t){const e={handler:t};return this._handlers.push(e),e}remove_callback(t){let e=this._handlers.indexOf(t);e>-1&&this._handers.splice(e,1)}notify_callbacks(t){this._handlers.forEach((function(e){e.handler(t)}))}set(t){if(this._terminated)throw new Error("varible terminated");const e=[{id:this._id,data:t}];return this._coll.update({insert:e,reset:!1})}get(){return this._coll.has(this._id)?this._coll.get(this._id).data:this._options.value}ss_client_terminate(){this._terminated=!0,this._coll.remove_callback(this._handle)}}const o=function(){return performance.now()/1e3},r=function(){return new Date/1e3},c=function(){const t=o(),e=r();return{now:function(){const s=o();return e+(s-t)}}}();class _{constructor(t){this._ssclient=t,this._pinger=new a(this._onping.bind(this)),this._samples=[],this._trans=1e3,this._skew=0}resume(){this._pinger.resume()}pause(){this._pinger.pause()}_onping(){const t=c.now();this._ssclient.get("/clock").then((({ok:e,data:s})=>{if(e){const e=c.now();this._add_sample(t,s,e)}}))}_add_sample(t,e,s){let n=(s-t)/2,i=e-(s+t)/2,o=[t,e,s,n,i];this._samples.push(o),this._samples.length>30&&this._samples.shift(),n=1e5,i=0;for(const t of this._samples)t[3]<n&&(n=t[3],i=t[4]);this._skew=i,this._trans=n}get skew(){return this._skew}get trans(){return this._trans}now(){return c.now()+this._skew}}const h=[...new Array(3).fill(20),...new Array(7).fill(500),1e4];class a{constructor(t){this._count=0,this._tid=void 0,this._callback=t,this._ping=this.ping.bind(this),this._delays=[...h]}pause(){clearTimeout(this._tid)}resume(){clearTimeout(this._tid),this.ping()}restart(){this._delays=[...h],clearTimeout(this._tid),this.ping()}ping(){let t=this._delays[0];this._delays.length>1&&this._delays.shift(),this._callback&&this._callback(),this._tid=setTimeout(this._ping,t)}}const l=Object.freeze({MESSAGE:"MESSAGE",REQUEST:"REQUEST",REPLY:"REPLY"}),d=Object.freeze({GET:"GET",PUT:"PUT",NOTIFY:"NOTIFY"});class u extends s{constructor(t,e){super(t,e),this._reqid=0,this._pending=new Map,this._subs_map=new Map,this._coll_map=new Map,this._var_map=new Map,this._server_clock}on_connect(){if(console.log(`Connect  ${this.url}`),this._subs_map.size>0){const t=[...this._subs_map.entries()];this.update("/subs",{insert:t,reset:!0})}null!=this._server_clock&&this._server_clock.resume()}on_disconnect(){console.error(`Disconnect ${this.url}`),null!=this._server_clock&&this._server_clock.pause()}on_error(t){const{debug:e=!1}=this._options;e&&console.log(`Communication Error: ${t}`)}on_message(t){let e=JSON.parse(t);if(e.type==l.REPLY){let t=e.tunnel;if(this._pending.has(t)){let s=this._pending.get(t);this._pending.delete(t);const{ok:n,data:i}=e;s({ok:n,data:i})}}else e.type==l.MESSAGE&&e.cmd==d.NOTIFY&&this._handle_notify(e)}_handle_notify(t){const e=this._coll_map.get(t.path);null!=e&&e._ssclient_update(t.data)}_request(e,s,n){const i=this._reqid++,o={type:l.REQUEST,cmd:e,path:s,arg:n,tunnel:i};this.send(JSON.stringify(o));let[r,c]=t();return this._pending.set(i,c),r.then((({ok:t,data:n})=>(e==d.PUT&&"/subs"==s&&t&&(this._subs_map=new Map(n)),{ok:t,path:s,data:n})))}_sub(t){if(this.connected){new Map([...this._subs_map]).set(t,{});const e=[...this._subs_map.entries()];return this.update("/subs",{insert:e,reset:!0})}return this._subs_map.set(t,{}),Promise.resolve({ok:!0,path:t,data:void 0})}_unsub(t){const e=new Map([...this._subs_map]);e.delete(t);const s=[...e.entries()];return this.update("/subs",{insert:s,reset:!0})}get clock(){return null==this._server_clock&&(this._server_clock=new _(this),this.connected&&this._server_clock.resume()),this._server_clock}get(t){return this._request(d.GET,t)}update(t,e){return this._request(d.PUT,t,e)}acquire_collection(t,e){return this._subs_map.has(t)||this._sub(t),this._coll_map.has(t)||this._coll_map.set(t,new n(this,t,e)),this._coll_map.get(t)}acquire_variable(t,e,s){const n=this.acquire_collection(t);this._var_map.has(t)||this._var_map.set(t,new Map);const o=this._var_map.get(t);return o.get(e)||o.set(e,new i(n,e,s)),o.get(e)}release(t){this._subs_map.has(t)&&this._unsub(t);this._coll_map.get(t)._ssclient_terminate();const e=this._var_map.get(t);if(null!=e)for(const t of e.values())t._ssclient_terminate();this._coll_map.delete(t),this._var_map.delete(t)}}function p(t){const{id:e,itv:s,data:n}=t;let i=JSON.stringify(n);return`\n        <div>\n            <button id="delete">X</button>\n            ${`<span class="id">${e}</span>`}: ${`<span class="itv">${null!=s?JSON.stringify(s):""}</span>`} ${`<span class="data">${i}</span>`}\n        </div>`}class m{constructor(t,e,s={}){this._coll=t,this._elem=e,this._handle=this._coll.add_callback(this._onchange.bind(this));let n={delete:!1,toString:p};this._options={...n,...s},this._options.delete&&e.addEventListener("click",(t=>{const e=t.target.closest("#delete");if(e){const s=e.closest(".list-item");s&&(this._coll.update({remove:[s.id]}),t.stopPropagation())}}));const i=this._coll.get().map((t=>({id:t.id,new:t})));this._onchange(i)}_onchange(t){const{toString:e}=this._options;for(let s of t)if(s.new){let t=this._elem.querySelector(`#${s.id}`);null==t&&(t=document.createElement("div"),t.setAttribute("id",s.id),t.classList.add("list-item"),this._elem.appendChild(t)),t.innerHTML=e(s.new)}else if(s.old){let t=this._elem.querySelector(`#${s.id}`);t&&t.parentNode.removeChild(t)}}}export{m as CollectionViewer,u as SharedStateClient};
